// Generated by gencpp from file car_interfaces/VehOperatingData.msg
// DO NOT EDIT!


#ifndef CAR_INTERFACES_MESSAGE_VEHOPERATINGDATA_H
#define CAR_INTERFACES_MESSAGE_VEHOPERATINGDATA_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace car_interfaces
{
template <class ContainerAllocator>
struct VehOperatingData_
{
  typedef VehOperatingData_<ContainerAllocator> Type;

  VehOperatingData_()
    : cotton_box_control(0)
    , cotton_unloading(0)
    , Head_control(0)
    , Engine_power(0)
    , Target_Fan_gear(0)
    , Door_control(0)
    , flag(0)  {
    }
  VehOperatingData_(const ContainerAllocator& _alloc)
    : cotton_box_control(0)
    , cotton_unloading(0)
    , Head_control(0)
    , Engine_power(0)
    , Target_Fan_gear(0)
    , Door_control(0)
    , flag(0)  {
  (void)_alloc;
    }



   typedef int8_t _cotton_box_control_type;
  _cotton_box_control_type cotton_box_control;

   typedef int8_t _cotton_unloading_type;
  _cotton_unloading_type cotton_unloading;

   typedef int8_t _Head_control_type;
  _Head_control_type Head_control;

   typedef int8_t _Engine_power_type;
  _Engine_power_type Engine_power;

   typedef int8_t _Target_Fan_gear_type;
  _Target_Fan_gear_type Target_Fan_gear;

   typedef int8_t _Door_control_type;
  _Door_control_type Door_control;

   typedef int8_t _flag_type;
  _flag_type flag;





  typedef boost::shared_ptr< ::car_interfaces::VehOperatingData_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::car_interfaces::VehOperatingData_<ContainerAllocator> const> ConstPtr;

}; // struct VehOperatingData_

typedef ::car_interfaces::VehOperatingData_<std::allocator<void> > VehOperatingData;

typedef boost::shared_ptr< ::car_interfaces::VehOperatingData > VehOperatingDataPtr;
typedef boost::shared_ptr< ::car_interfaces::VehOperatingData const> VehOperatingDataConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::car_interfaces::VehOperatingData_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::car_interfaces::VehOperatingData_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::car_interfaces::VehOperatingData_<ContainerAllocator1> & lhs, const ::car_interfaces::VehOperatingData_<ContainerAllocator2> & rhs)
{
  return lhs.cotton_box_control == rhs.cotton_box_control &&
    lhs.cotton_unloading == rhs.cotton_unloading &&
    lhs.Head_control == rhs.Head_control &&
    lhs.Engine_power == rhs.Engine_power &&
    lhs.Target_Fan_gear == rhs.Target_Fan_gear &&
    lhs.Door_control == rhs.Door_control &&
    lhs.flag == rhs.flag;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::car_interfaces::VehOperatingData_<ContainerAllocator1> & lhs, const ::car_interfaces::VehOperatingData_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace car_interfaces

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::car_interfaces::VehOperatingData_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::car_interfaces::VehOperatingData_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::car_interfaces::VehOperatingData_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::car_interfaces::VehOperatingData_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::car_interfaces::VehOperatingData_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::car_interfaces::VehOperatingData_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::car_interfaces::VehOperatingData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "6881f1f50cfa4ccbc6e29bdbd978adae";
  }

  static const char* value(const ::car_interfaces::VehOperatingData_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x6881f1f50cfa4ccbULL;
  static const uint64_t static_value2 = 0xc6e29bdbd978adaeULL;
};

template<class ContainerAllocator>
struct DataType< ::car_interfaces::VehOperatingData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "car_interfaces/VehOperatingData";
  }

  static const char* value(const ::car_interfaces::VehOperatingData_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::car_interfaces::VehOperatingData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# float64  timestamp  # 数据帧时间戳\n"
"# float32  cotton_picker_fan_Enabler    #  使能采头与风机，1-使能；0-保持不变；\n"
"# float32  cotton_bin_upper    # 升棉箱指令，1-提升；0-保持不变；\n"
"# uint8  cotton_bin_lower   # 降棉箱指令，1-降低；0-保持不变；\n"
"# uint8  cotton_bin_tilting   #  棉箱倾斜指令（需要持续作用，长按），1-倾斜；0-保持不变；\n"
"# uint8  cotton_bin_restore # 棉箱回正指令（需要持续作用，长按），1-回正；0-保持不变；\n"
"# uint8  cotton_unload  # 卸棉花指令（传送带），1-卸载；0-保持不变；\n"
"# float32  process_time    # 进程处理时间\n"
"\n"
"# int8 operate# 0-不使能 1-使能\n"
"# int8 unloading # 0-不使能 1-使能\n"
"\n"
"\n"
"\n"
"# 10.17 cyun\n"
"int8 cotton_box_control   #0-不动作 1-棉箱倾斜 2-无动作 3-无动作 4-棉箱倾斜回正 \n"
"# int8 cotton_picker_enable       # 采头风机使能 0-不使能 1-使能 \n"
"int8 cotton_unloading         # 卸棉传送带  0-关闭 1-启动\n"
"# auto_enable= 1           #enable_single;\n"
"# speed_range= 0                  \n"
"# throttle_opening=0  #-100~100       \n"
"int8 Head_control    #1-采头下降 2-左采头上升（需要使能）3-右采头上升（需要使能） 4-采头同升（需要使能） \n"
"int8 Engine_power     # 1-低速 2-中速 3-高速               \n"
"int8 Target_Fan_gear  # 采头风机 0-不接通 1-风机 2-采头风机\n"
"# Reserve_1=0       # 驻车信号 0-驻车 1-取消\n"
"# Target_steering_angle = 0 #方向盘转角\n"
"# brake_enable=0  #刹车使能\n"
"# brake_pressure_request=0 #刹车行程\n"
"# Reserve_2=0\n"
"# Target_turn_light=0\n"
"int8 Door_control    #门控 0-停止 1-开门 2-关门\n"
"# Reserve_3=0\n"
"\n"
"int8 flag # 发送到线控成功\n"
"\n"
"# operate = 0 # 采棉动作流程\n"
"# unloading = 0# 卸棉流程\n"
;
  }

  static const char* value(const ::car_interfaces::VehOperatingData_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::car_interfaces::VehOperatingData_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.cotton_box_control);
      stream.next(m.cotton_unloading);
      stream.next(m.Head_control);
      stream.next(m.Engine_power);
      stream.next(m.Target_Fan_gear);
      stream.next(m.Door_control);
      stream.next(m.flag);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct VehOperatingData_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::car_interfaces::VehOperatingData_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::car_interfaces::VehOperatingData_<ContainerAllocator>& v)
  {
    s << indent << "cotton_box_control: ";
    Printer<int8_t>::stream(s, indent + "  ", v.cotton_box_control);
    s << indent << "cotton_unloading: ";
    Printer<int8_t>::stream(s, indent + "  ", v.cotton_unloading);
    s << indent << "Head_control: ";
    Printer<int8_t>::stream(s, indent + "  ", v.Head_control);
    s << indent << "Engine_power: ";
    Printer<int8_t>::stream(s, indent + "  ", v.Engine_power);
    s << indent << "Target_Fan_gear: ";
    Printer<int8_t>::stream(s, indent + "  ", v.Target_Fan_gear);
    s << indent << "Door_control: ";
    Printer<int8_t>::stream(s, indent + "  ", v.Door_control);
    s << indent << "flag: ";
    Printer<int8_t>::stream(s, indent + "  ", v.flag);
  }
};

} // namespace message_operations
} // namespace ros

#endif // CAR_INTERFACES_MESSAGE_VEHOPERATINGDATA_H
