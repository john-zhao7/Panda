// Generated by gencpp from file car_interfaces/CarActionInterface.msg
// DO NOT EDIT!


#ifndef CAR_INTERFACES_MESSAGE_CARACTIONINTERFACE_H
#define CAR_INTERFACES_MESSAGE_CARACTIONINTERFACE_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace car_interfaces
{
template <class ContainerAllocator>
struct CarActionInterface_
{
  typedef CarActionInterface_<ContainerAllocator> Type;

  CarActionInterface_()
    : flag(0)
    , operate(0)
    , unloading(0)
    , cotton_box_control(0)
    , cotton_unloading(0)
    , Head_control(0)
    , Engine_power(0)
    , Target_Fan_gear(0)
    , Door_control(0)  {
    }
  CarActionInterface_(const ContainerAllocator& _alloc)
    : flag(0)
    , operate(0)
    , unloading(0)
    , cotton_box_control(0)
    , cotton_unloading(0)
    , Head_control(0)
    , Engine_power(0)
    , Target_Fan_gear(0)
    , Door_control(0)  {
  (void)_alloc;
    }



   typedef int8_t _flag_type;
  _flag_type flag;

   typedef int8_t _operate_type;
  _operate_type operate;

   typedef int8_t _unloading_type;
  _unloading_type unloading;

   typedef int8_t _cotton_box_control_type;
  _cotton_box_control_type cotton_box_control;

   typedef int8_t _cotton_unloading_type;
  _cotton_unloading_type cotton_unloading;

   typedef int8_t _Head_control_type;
  _Head_control_type Head_control;

   typedef int8_t _Engine_power_type;
  _Engine_power_type Engine_power;

   typedef int8_t _Target_Fan_gear_type;
  _Target_Fan_gear_type Target_Fan_gear;

   typedef int8_t _Door_control_type;
  _Door_control_type Door_control;





  typedef boost::shared_ptr< ::car_interfaces::CarActionInterface_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::car_interfaces::CarActionInterface_<ContainerAllocator> const> ConstPtr;

}; // struct CarActionInterface_

typedef ::car_interfaces::CarActionInterface_<std::allocator<void> > CarActionInterface;

typedef boost::shared_ptr< ::car_interfaces::CarActionInterface > CarActionInterfacePtr;
typedef boost::shared_ptr< ::car_interfaces::CarActionInterface const> CarActionInterfaceConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::car_interfaces::CarActionInterface_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::car_interfaces::CarActionInterface_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::car_interfaces::CarActionInterface_<ContainerAllocator1> & lhs, const ::car_interfaces::CarActionInterface_<ContainerAllocator2> & rhs)
{
  return lhs.flag == rhs.flag &&
    lhs.operate == rhs.operate &&
    lhs.unloading == rhs.unloading &&
    lhs.cotton_box_control == rhs.cotton_box_control &&
    lhs.cotton_unloading == rhs.cotton_unloading &&
    lhs.Head_control == rhs.Head_control &&
    lhs.Engine_power == rhs.Engine_power &&
    lhs.Target_Fan_gear == rhs.Target_Fan_gear &&
    lhs.Door_control == rhs.Door_control;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::car_interfaces::CarActionInterface_<ContainerAllocator1> & lhs, const ::car_interfaces::CarActionInterface_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace car_interfaces

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::car_interfaces::CarActionInterface_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::car_interfaces::CarActionInterface_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::car_interfaces::CarActionInterface_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::car_interfaces::CarActionInterface_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::car_interfaces::CarActionInterface_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::car_interfaces::CarActionInterface_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::car_interfaces::CarActionInterface_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ca82fc4562e5f4077985eac24b00c6b1";
  }

  static const char* value(const ::car_interfaces::CarActionInterface_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xca82fc4562e5f407ULL;
  static const uint64_t static_value2 = 0x7985eac24b00c6b1ULL;
};

template<class ContainerAllocator>
struct DataType< ::car_interfaces::CarActionInterface_<ContainerAllocator> >
{
  static const char* value()
  {
    return "car_interfaces/CarActionInterface";
  }

  static const char* value(const ::car_interfaces::CarActionInterface_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::car_interfaces::CarActionInterface_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# topic car_action_data\n"
"int8 flag                       #标志位\n"
"int8 operate #0-不使能 1-使能\n"
"# 采头下降\n"
"# 风机打开 \n"
"# 中速档\n"
"# 风机采头打开  \n"
"# 高速档\n"
"\n"
"\n"
"# 卸棉动作（全体）启动按钮\n"
"int8 unloading # 0-不使能 1-使能\n"
"# 棉线倾斜\n"
"# 传送带  停留一段时间（按照装满来说是30s-1min吧）\n"
"\n"
"\n"
"# 其余动作按钮\n"
"int8 cotton_box_control 		 #0-不动作 1-棉箱倾斜 2-无动作 3-无动作 4-棉箱倾斜回正 \n"
"# int8 cotton_picker_enable      	 # 采头风机使能 0-不使能 1-使能 \n"
"int8 cotton_unloading                    # 卸棉传送带  0-关闭 1-启动\n"
"int8 Head_control    			 # 0-不动作 1-采头下降 2-左采头上升（需要使能）3-右采头上升（需要使能） 4-采头同升（需要使能）\n"
"int8 Engine_power     			 # 0-不动作 1-低速 2-中速 3-高速\n"
"int8 Target_Fan_gear 			 # 采头风机 0-不接通 1-风机 2-采头风机\n"
"int8 Door_control    			 #门控 0-停止 1-开门 2-关门\n"
;
  }

  static const char* value(const ::car_interfaces::CarActionInterface_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::car_interfaces::CarActionInterface_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.flag);
      stream.next(m.operate);
      stream.next(m.unloading);
      stream.next(m.cotton_box_control);
      stream.next(m.cotton_unloading);
      stream.next(m.Head_control);
      stream.next(m.Engine_power);
      stream.next(m.Target_Fan_gear);
      stream.next(m.Door_control);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct CarActionInterface_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::car_interfaces::CarActionInterface_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::car_interfaces::CarActionInterface_<ContainerAllocator>& v)
  {
    s << indent << "flag: ";
    Printer<int8_t>::stream(s, indent + "  ", v.flag);
    s << indent << "operate: ";
    Printer<int8_t>::stream(s, indent + "  ", v.operate);
    s << indent << "unloading: ";
    Printer<int8_t>::stream(s, indent + "  ", v.unloading);
    s << indent << "cotton_box_control: ";
    Printer<int8_t>::stream(s, indent + "  ", v.cotton_box_control);
    s << indent << "cotton_unloading: ";
    Printer<int8_t>::stream(s, indent + "  ", v.cotton_unloading);
    s << indent << "Head_control: ";
    Printer<int8_t>::stream(s, indent + "  ", v.Head_control);
    s << indent << "Engine_power: ";
    Printer<int8_t>::stream(s, indent + "  ", v.Engine_power);
    s << indent << "Target_Fan_gear: ";
    Printer<int8_t>::stream(s, indent + "  ", v.Target_Fan_gear);
    s << indent << "Door_control: ";
    Printer<int8_t>::stream(s, indent + "  ", v.Door_control);
  }
};

} // namespace message_operations
} // namespace ros

#endif // CAR_INTERFACES_MESSAGE_CARACTIONINTERFACE_H
