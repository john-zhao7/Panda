// Generated by gencpp from file car_interfaces/GpsImuAddInterface.msg
// DO NOT EDIT!


#ifndef CAR_INTERFACES_MESSAGE_GPSIMUADDINTERFACE_H
#define CAR_INTERFACES_MESSAGE_GPSIMUADDINTERFACE_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace car_interfaces
{
template <class ContainerAllocator>
struct GpsImuAddInterface_
{
  typedef GpsImuAddInterface_<ContainerAllocator> Type;

  GpsImuAddInterface_()
    : header()
    , gps_time(0)
    , AngRateRawX(0.0)
    , AngRateRawY(0.0)
    , AngRateRawZ(0.0)
    , AccelRawX(0.0)
    , AccelRawY(0.0)
    , AccelRawZ(0.0)
    , PosESigma(0.0)
    , PosNSigma(0.0)
    , PosUSigma(0.0)
    , VelESigma(0.0)
    , VelNSigma(0.0)
    , VelUSigma(0.0)
    , VelSigma(0.0)
    , AccelX(0.0)
    , AccelY(0.0)
    , AccelZ(0.0)
    , AngleHeadingSigma(0.0)
    , AnglePitchSigma(0.0)
    , AngleRollSigma(0.0)
    , AngRateX(0.0)
    , AngRateY(0.0)
    , AngRateZ(0.0)
    , GpsNumSats2Used(0)
    , GpsNumSats(0)
    , GpsNumSats2(0)
    , Rear_posX(0.0)
    , Rear_posY(0.0)
    , Rear_posZ(0.0)
    , process_time(0.0)  {
    }
  GpsImuAddInterface_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , gps_time(0)
    , AngRateRawX(0.0)
    , AngRateRawY(0.0)
    , AngRateRawZ(0.0)
    , AccelRawX(0.0)
    , AccelRawY(0.0)
    , AccelRawZ(0.0)
    , PosESigma(0.0)
    , PosNSigma(0.0)
    , PosUSigma(0.0)
    , VelESigma(0.0)
    , VelNSigma(0.0)
    , VelUSigma(0.0)
    , VelSigma(0.0)
    , AccelX(0.0)
    , AccelY(0.0)
    , AccelZ(0.0)
    , AngleHeadingSigma(0.0)
    , AnglePitchSigma(0.0)
    , AngleRollSigma(0.0)
    , AngRateX(0.0)
    , AngRateY(0.0)
    , AngRateZ(0.0)
    , GpsNumSats2Used(0)
    , GpsNumSats(0)
    , GpsNumSats2(0)
    , Rear_posX(0.0)
    , Rear_posY(0.0)
    , Rear_posZ(0.0)
    , process_time(0.0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef int64_t _gps_time_type;
  _gps_time_type gps_time;

   typedef double _AngRateRawX_type;
  _AngRateRawX_type AngRateRawX;

   typedef double _AngRateRawY_type;
  _AngRateRawY_type AngRateRawY;

   typedef double _AngRateRawZ_type;
  _AngRateRawZ_type AngRateRawZ;

   typedef double _AccelRawX_type;
  _AccelRawX_type AccelRawX;

   typedef double _AccelRawY_type;
  _AccelRawY_type AccelRawY;

   typedef double _AccelRawZ_type;
  _AccelRawZ_type AccelRawZ;

   typedef double _PosESigma_type;
  _PosESigma_type PosESigma;

   typedef double _PosNSigma_type;
  _PosNSigma_type PosNSigma;

   typedef double _PosUSigma_type;
  _PosUSigma_type PosUSigma;

   typedef double _VelESigma_type;
  _VelESigma_type VelESigma;

   typedef double _VelNSigma_type;
  _VelNSigma_type VelNSigma;

   typedef double _VelUSigma_type;
  _VelUSigma_type VelUSigma;

   typedef double _VelSigma_type;
  _VelSigma_type VelSigma;

   typedef double _AccelX_type;
  _AccelX_type AccelX;

   typedef double _AccelY_type;
  _AccelY_type AccelY;

   typedef double _AccelZ_type;
  _AccelZ_type AccelZ;

   typedef double _AngleHeadingSigma_type;
  _AngleHeadingSigma_type AngleHeadingSigma;

   typedef double _AnglePitchSigma_type;
  _AnglePitchSigma_type AnglePitchSigma;

   typedef double _AngleRollSigma_type;
  _AngleRollSigma_type AngleRollSigma;

   typedef double _AngRateX_type;
  _AngRateX_type AngRateX;

   typedef double _AngRateY_type;
  _AngRateY_type AngRateY;

   typedef double _AngRateZ_type;
  _AngRateZ_type AngRateZ;

   typedef int32_t _GpsNumSats2Used_type;
  _GpsNumSats2Used_type GpsNumSats2Used;

   typedef int32_t _GpsNumSats_type;
  _GpsNumSats_type GpsNumSats;

   typedef int32_t _GpsNumSats2_type;
  _GpsNumSats2_type GpsNumSats2;

   typedef double _Rear_posX_type;
  _Rear_posX_type Rear_posX;

   typedef double _Rear_posY_type;
  _Rear_posY_type Rear_posY;

   typedef double _Rear_posZ_type;
  _Rear_posZ_type Rear_posZ;

   typedef float _process_time_type;
  _process_time_type process_time;





  typedef boost::shared_ptr< ::car_interfaces::GpsImuAddInterface_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::car_interfaces::GpsImuAddInterface_<ContainerAllocator> const> ConstPtr;

}; // struct GpsImuAddInterface_

typedef ::car_interfaces::GpsImuAddInterface_<std::allocator<void> > GpsImuAddInterface;

typedef boost::shared_ptr< ::car_interfaces::GpsImuAddInterface > GpsImuAddInterfacePtr;
typedef boost::shared_ptr< ::car_interfaces::GpsImuAddInterface const> GpsImuAddInterfaceConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::car_interfaces::GpsImuAddInterface_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::car_interfaces::GpsImuAddInterface_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::car_interfaces::GpsImuAddInterface_<ContainerAllocator1> & lhs, const ::car_interfaces::GpsImuAddInterface_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.gps_time == rhs.gps_time &&
    lhs.AngRateRawX == rhs.AngRateRawX &&
    lhs.AngRateRawY == rhs.AngRateRawY &&
    lhs.AngRateRawZ == rhs.AngRateRawZ &&
    lhs.AccelRawX == rhs.AccelRawX &&
    lhs.AccelRawY == rhs.AccelRawY &&
    lhs.AccelRawZ == rhs.AccelRawZ &&
    lhs.PosESigma == rhs.PosESigma &&
    lhs.PosNSigma == rhs.PosNSigma &&
    lhs.PosUSigma == rhs.PosUSigma &&
    lhs.VelESigma == rhs.VelESigma &&
    lhs.VelNSigma == rhs.VelNSigma &&
    lhs.VelUSigma == rhs.VelUSigma &&
    lhs.VelSigma == rhs.VelSigma &&
    lhs.AccelX == rhs.AccelX &&
    lhs.AccelY == rhs.AccelY &&
    lhs.AccelZ == rhs.AccelZ &&
    lhs.AngleHeadingSigma == rhs.AngleHeadingSigma &&
    lhs.AnglePitchSigma == rhs.AnglePitchSigma &&
    lhs.AngleRollSigma == rhs.AngleRollSigma &&
    lhs.AngRateX == rhs.AngRateX &&
    lhs.AngRateY == rhs.AngRateY &&
    lhs.AngRateZ == rhs.AngRateZ &&
    lhs.GpsNumSats2Used == rhs.GpsNumSats2Used &&
    lhs.GpsNumSats == rhs.GpsNumSats &&
    lhs.GpsNumSats2 == rhs.GpsNumSats2 &&
    lhs.Rear_posX == rhs.Rear_posX &&
    lhs.Rear_posY == rhs.Rear_posY &&
    lhs.Rear_posZ == rhs.Rear_posZ &&
    lhs.process_time == rhs.process_time;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::car_interfaces::GpsImuAddInterface_<ContainerAllocator1> & lhs, const ::car_interfaces::GpsImuAddInterface_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace car_interfaces

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::car_interfaces::GpsImuAddInterface_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::car_interfaces::GpsImuAddInterface_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::car_interfaces::GpsImuAddInterface_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::car_interfaces::GpsImuAddInterface_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::car_interfaces::GpsImuAddInterface_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::car_interfaces::GpsImuAddInterface_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::car_interfaces::GpsImuAddInterface_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ccdf9c1baf49a9162649abaf0da4c464";
  }

  static const char* value(const ::car_interfaces::GpsImuAddInterface_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xccdf9c1baf49a916ULL;
  static const uint64_t static_value2 = 0x2649abaf0da4c464ULL;
};

template<class ContainerAllocator>
struct DataType< ::car_interfaces::GpsImuAddInterface_<ContainerAllocator> >
{
  static const char* value()
  {
    return "car_interfaces/GpsImuAddInterface";
  }

  static const char* value(const ::car_interfaces::GpsImuAddInterface_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::car_interfaces::GpsImuAddInterface_<ContainerAllocator> >
{
  static const char* value()
  {
    return "std_msgs/Header header       # ros时间戳\n"
"int64  gps_time              # 时间戳\n"
"float64  AngRateRawX         # 角速度x\n"
"float64  AngRateRawY         # 角速度y\n"
"float64  AngRateRawZ         # 角速度z\n"
"float64  AccelRawX             # x轴加速度\n"
"float64  AccelRawY             # y轴加速度\n"
"float64  AccelRawZ             # z轴加速度\n"
"float64 PosESigma           #东向位置标准差\n"
"float64 PosNSigma          #北向位置标准差\n"
"float64 PosUSigma          #天向位置标准差\n"
"float64  VelESigma         # 东向速度标准差\n"
"float64  VelNSigma        # 北向速度标准差\n"
"float64  VelUSigma        # 天向速度标准差\n"
"float64  VelSigma          # 车辆速度标准差\n"
"float64  AccelX         # 车辆坐标系x轴加速度\n"
"float64  AccelY         # 车辆坐标系y轴加速度\n"
"float64  AccelZ         # 车辆坐标系z轴加速度\n"
"float64  AngleHeadingSigma         # 偏航角标准差\n"
"float64  AnglePitchSigma        # 俯仰角标准差\n"
"float64  AngleRollSigma         # 横滚角标准差\n"
"float64  AngRateX                  # 车辆坐标系x轴角速度\n"
"float64  AngRateY                  # 车辆坐标系y轴角速度\n"
"float64  AngRateZ                  # 车辆坐标系z轴角速度\n"
"int32  GpsNumSats2Used      #辅天线使用卫星数\n"
"int32  GpsNumSats                #主天线搜星数\n"
"int32  GpsNumSats2              #副天线搜星数\n"
"float64 Rear_posX                  #后轴中心点UTM坐标x\n"
"float64 Rear_posY                  #后轴中心点UTM坐标y\n"
"float64 Rear_posZ                  #后轴中心点UTM坐标z\n"
"float32  process_time    # 进程处理时间\n"
"\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::car_interfaces::GpsImuAddInterface_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::car_interfaces::GpsImuAddInterface_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.gps_time);
      stream.next(m.AngRateRawX);
      stream.next(m.AngRateRawY);
      stream.next(m.AngRateRawZ);
      stream.next(m.AccelRawX);
      stream.next(m.AccelRawY);
      stream.next(m.AccelRawZ);
      stream.next(m.PosESigma);
      stream.next(m.PosNSigma);
      stream.next(m.PosUSigma);
      stream.next(m.VelESigma);
      stream.next(m.VelNSigma);
      stream.next(m.VelUSigma);
      stream.next(m.VelSigma);
      stream.next(m.AccelX);
      stream.next(m.AccelY);
      stream.next(m.AccelZ);
      stream.next(m.AngleHeadingSigma);
      stream.next(m.AnglePitchSigma);
      stream.next(m.AngleRollSigma);
      stream.next(m.AngRateX);
      stream.next(m.AngRateY);
      stream.next(m.AngRateZ);
      stream.next(m.GpsNumSats2Used);
      stream.next(m.GpsNumSats);
      stream.next(m.GpsNumSats2);
      stream.next(m.Rear_posX);
      stream.next(m.Rear_posY);
      stream.next(m.Rear_posZ);
      stream.next(m.process_time);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct GpsImuAddInterface_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::car_interfaces::GpsImuAddInterface_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::car_interfaces::GpsImuAddInterface_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "gps_time: ";
    Printer<int64_t>::stream(s, indent + "  ", v.gps_time);
    s << indent << "AngRateRawX: ";
    Printer<double>::stream(s, indent + "  ", v.AngRateRawX);
    s << indent << "AngRateRawY: ";
    Printer<double>::stream(s, indent + "  ", v.AngRateRawY);
    s << indent << "AngRateRawZ: ";
    Printer<double>::stream(s, indent + "  ", v.AngRateRawZ);
    s << indent << "AccelRawX: ";
    Printer<double>::stream(s, indent + "  ", v.AccelRawX);
    s << indent << "AccelRawY: ";
    Printer<double>::stream(s, indent + "  ", v.AccelRawY);
    s << indent << "AccelRawZ: ";
    Printer<double>::stream(s, indent + "  ", v.AccelRawZ);
    s << indent << "PosESigma: ";
    Printer<double>::stream(s, indent + "  ", v.PosESigma);
    s << indent << "PosNSigma: ";
    Printer<double>::stream(s, indent + "  ", v.PosNSigma);
    s << indent << "PosUSigma: ";
    Printer<double>::stream(s, indent + "  ", v.PosUSigma);
    s << indent << "VelESigma: ";
    Printer<double>::stream(s, indent + "  ", v.VelESigma);
    s << indent << "VelNSigma: ";
    Printer<double>::stream(s, indent + "  ", v.VelNSigma);
    s << indent << "VelUSigma: ";
    Printer<double>::stream(s, indent + "  ", v.VelUSigma);
    s << indent << "VelSigma: ";
    Printer<double>::stream(s, indent + "  ", v.VelSigma);
    s << indent << "AccelX: ";
    Printer<double>::stream(s, indent + "  ", v.AccelX);
    s << indent << "AccelY: ";
    Printer<double>::stream(s, indent + "  ", v.AccelY);
    s << indent << "AccelZ: ";
    Printer<double>::stream(s, indent + "  ", v.AccelZ);
    s << indent << "AngleHeadingSigma: ";
    Printer<double>::stream(s, indent + "  ", v.AngleHeadingSigma);
    s << indent << "AnglePitchSigma: ";
    Printer<double>::stream(s, indent + "  ", v.AnglePitchSigma);
    s << indent << "AngleRollSigma: ";
    Printer<double>::stream(s, indent + "  ", v.AngleRollSigma);
    s << indent << "AngRateX: ";
    Printer<double>::stream(s, indent + "  ", v.AngRateX);
    s << indent << "AngRateY: ";
    Printer<double>::stream(s, indent + "  ", v.AngRateY);
    s << indent << "AngRateZ: ";
    Printer<double>::stream(s, indent + "  ", v.AngRateZ);
    s << indent << "GpsNumSats2Used: ";
    Printer<int32_t>::stream(s, indent + "  ", v.GpsNumSats2Used);
    s << indent << "GpsNumSats: ";
    Printer<int32_t>::stream(s, indent + "  ", v.GpsNumSats);
    s << indent << "GpsNumSats2: ";
    Printer<int32_t>::stream(s, indent + "  ", v.GpsNumSats2);
    s << indent << "Rear_posX: ";
    Printer<double>::stream(s, indent + "  ", v.Rear_posX);
    s << indent << "Rear_posY: ";
    Printer<double>::stream(s, indent + "  ", v.Rear_posY);
    s << indent << "Rear_posZ: ";
    Printer<double>::stream(s, indent + "  ", v.Rear_posZ);
    s << indent << "process_time: ";
    Printer<float>::stream(s, indent + "  ", v.process_time);
  }
};

} // namespace message_operations
} // namespace ros

#endif // CAR_INTERFACES_MESSAGE_GPSIMUADDINTERFACE_H
