// Generated by gencpp from file hmi/CarOriInterface.msg
// DO NOT EDIT!


#ifndef HMI_MESSAGE_CARORIINTERFACE_H
#define HMI_MESSAGE_CARORIINTERFACE_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace hmi
{
template <class ContainerAllocator>
struct CarOriInterface_
{
  typedef CarOriInterface_<ContainerAllocator> Type;

  CarOriInterface_()
    : timestamp(0.0)
    , id(0)
    , auto_enable(0)
    , carspeed(0.0)
    , steerangle(0.0)
    , current_angle(0.0)
    , gearpos(0)
    , brake_pressure_request(0.0)
    , brake_enable(0)
    , current_braking_percentage(0)
    , soc(0)
    , batteryvol(0)
    , batterydischargecur(0)
    , car_run_mode(0)
    , throttle_percentage(0)
    , left_light(0)
    , right_light(0)
    , reversing_light(0)
    , speaker(0)
    , start_button(0)
    , stop_button(0)
    , state(0)
    , error(0)
    , cotton_picker_fan_Enabler_act(0.0)
    , cotton_bin_upper_act(0.0)
    , cotton_bin_lower_act(0)
    , cotton_bin_tilting_act(0)
    , cotton_bin_restore_act(0)
    , cotton_unload_act(0)
    , cotton_picker_head_height(0.0)
    , Target_primary_gear_act(0)
    , Target_EngineSpeedLevel_act(0)
    , Target_speedlever_percentage_act(0)
    , process_time(0.0)
    , raw_controlled(0.0)
    , wait_wirectrl(0)  {
    }
  CarOriInterface_(const ContainerAllocator& _alloc)
    : timestamp(0.0)
    , id(0)
    , auto_enable(0)
    , carspeed(0.0)
    , steerangle(0.0)
    , current_angle(0.0)
    , gearpos(0)
    , brake_pressure_request(0.0)
    , brake_enable(0)
    , current_braking_percentage(0)
    , soc(0)
    , batteryvol(0)
    , batterydischargecur(0)
    , car_run_mode(0)
    , throttle_percentage(0)
    , left_light(0)
    , right_light(0)
    , reversing_light(0)
    , speaker(0)
    , start_button(0)
    , stop_button(0)
    , state(0)
    , error(0)
    , cotton_picker_fan_Enabler_act(0.0)
    , cotton_bin_upper_act(0.0)
    , cotton_bin_lower_act(0)
    , cotton_bin_tilting_act(0)
    , cotton_bin_restore_act(0)
    , cotton_unload_act(0)
    , cotton_picker_head_height(0.0)
    , Target_primary_gear_act(0)
    , Target_EngineSpeedLevel_act(0)
    , Target_speedlever_percentage_act(0)
    , process_time(0.0)
    , raw_controlled(0.0)
    , wait_wirectrl(0)  {
  (void)_alloc;
    }



   typedef double _timestamp_type;
  _timestamp_type timestamp;

   typedef uint8_t _id_type;
  _id_type id;

   typedef uint8_t _auto_enable_type;
  _auto_enable_type auto_enable;

   typedef float _carspeed_type;
  _carspeed_type carspeed;

   typedef float _steerangle_type;
  _steerangle_type steerangle;

   typedef float _current_angle_type;
  _current_angle_type current_angle;

   typedef int8_t _gearpos_type;
  _gearpos_type gearpos;

   typedef float _brake_pressure_request_type;
  _brake_pressure_request_type brake_pressure_request;

   typedef uint8_t _brake_enable_type;
  _brake_enable_type brake_enable;

   typedef uint8_t _current_braking_percentage_type;
  _current_braking_percentage_type current_braking_percentage;

   typedef uint8_t _soc_type;
  _soc_type soc;

   typedef uint8_t _batteryvol_type;
  _batteryvol_type batteryvol;

   typedef uint16_t _batterydischargecur_type;
  _batterydischargecur_type batterydischargecur;

   typedef uint8_t _car_run_mode_type;
  _car_run_mode_type car_run_mode;

   typedef int16_t _throttle_percentage_type;
  _throttle_percentage_type throttle_percentage;

   typedef uint8_t _left_light_type;
  _left_light_type left_light;

   typedef uint8_t _right_light_type;
  _right_light_type right_light;

   typedef uint8_t _reversing_light_type;
  _reversing_light_type reversing_light;

   typedef uint8_t _speaker_type;
  _speaker_type speaker;

   typedef uint8_t _start_button_type;
  _start_button_type start_button;

   typedef uint8_t _stop_button_type;
  _stop_button_type stop_button;

   typedef uint8_t _state_type;
  _state_type state;

   typedef uint8_t _error_type;
  _error_type error;

   typedef float _cotton_picker_fan_Enabler_act_type;
  _cotton_picker_fan_Enabler_act_type cotton_picker_fan_Enabler_act;

   typedef float _cotton_bin_upper_act_type;
  _cotton_bin_upper_act_type cotton_bin_upper_act;

   typedef uint8_t _cotton_bin_lower_act_type;
  _cotton_bin_lower_act_type cotton_bin_lower_act;

   typedef uint8_t _cotton_bin_tilting_act_type;
  _cotton_bin_tilting_act_type cotton_bin_tilting_act;

   typedef uint8_t _cotton_bin_restore_act_type;
  _cotton_bin_restore_act_type cotton_bin_restore_act;

   typedef uint8_t _cotton_unload_act_type;
  _cotton_unload_act_type cotton_unload_act;

   typedef float _cotton_picker_head_height_type;
  _cotton_picker_head_height_type cotton_picker_head_height;

   typedef uint8_t _Target_primary_gear_act_type;
  _Target_primary_gear_act_type Target_primary_gear_act;

   typedef uint8_t _Target_EngineSpeedLevel_act_type;
  _Target_EngineSpeedLevel_act_type Target_EngineSpeedLevel_act;

   typedef int16_t _Target_speedlever_percentage_act_type;
  _Target_speedlever_percentage_act_type Target_speedlever_percentage_act;

   typedef float _process_time_type;
  _process_time_type process_time;

   typedef float _raw_controlled_type;
  _raw_controlled_type raw_controlled;

   typedef int8_t _wait_wirectrl_type;
  _wait_wirectrl_type wait_wirectrl;





  typedef boost::shared_ptr< ::hmi::CarOriInterface_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::hmi::CarOriInterface_<ContainerAllocator> const> ConstPtr;

}; // struct CarOriInterface_

typedef ::hmi::CarOriInterface_<std::allocator<void> > CarOriInterface;

typedef boost::shared_ptr< ::hmi::CarOriInterface > CarOriInterfacePtr;
typedef boost::shared_ptr< ::hmi::CarOriInterface const> CarOriInterfaceConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::hmi::CarOriInterface_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::hmi::CarOriInterface_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::hmi::CarOriInterface_<ContainerAllocator1> & lhs, const ::hmi::CarOriInterface_<ContainerAllocator2> & rhs)
{
  return lhs.timestamp == rhs.timestamp &&
    lhs.id == rhs.id &&
    lhs.auto_enable == rhs.auto_enable &&
    lhs.carspeed == rhs.carspeed &&
    lhs.steerangle == rhs.steerangle &&
    lhs.current_angle == rhs.current_angle &&
    lhs.gearpos == rhs.gearpos &&
    lhs.brake_pressure_request == rhs.brake_pressure_request &&
    lhs.brake_enable == rhs.brake_enable &&
    lhs.current_braking_percentage == rhs.current_braking_percentage &&
    lhs.soc == rhs.soc &&
    lhs.batteryvol == rhs.batteryvol &&
    lhs.batterydischargecur == rhs.batterydischargecur &&
    lhs.car_run_mode == rhs.car_run_mode &&
    lhs.throttle_percentage == rhs.throttle_percentage &&
    lhs.left_light == rhs.left_light &&
    lhs.right_light == rhs.right_light &&
    lhs.reversing_light == rhs.reversing_light &&
    lhs.speaker == rhs.speaker &&
    lhs.start_button == rhs.start_button &&
    lhs.stop_button == rhs.stop_button &&
    lhs.state == rhs.state &&
    lhs.error == rhs.error &&
    lhs.cotton_picker_fan_Enabler_act == rhs.cotton_picker_fan_Enabler_act &&
    lhs.cotton_bin_upper_act == rhs.cotton_bin_upper_act &&
    lhs.cotton_bin_lower_act == rhs.cotton_bin_lower_act &&
    lhs.cotton_bin_tilting_act == rhs.cotton_bin_tilting_act &&
    lhs.cotton_bin_restore_act == rhs.cotton_bin_restore_act &&
    lhs.cotton_unload_act == rhs.cotton_unload_act &&
    lhs.cotton_picker_head_height == rhs.cotton_picker_head_height &&
    lhs.Target_primary_gear_act == rhs.Target_primary_gear_act &&
    lhs.Target_EngineSpeedLevel_act == rhs.Target_EngineSpeedLevel_act &&
    lhs.Target_speedlever_percentage_act == rhs.Target_speedlever_percentage_act &&
    lhs.process_time == rhs.process_time &&
    lhs.raw_controlled == rhs.raw_controlled &&
    lhs.wait_wirectrl == rhs.wait_wirectrl;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::hmi::CarOriInterface_<ContainerAllocator1> & lhs, const ::hmi::CarOriInterface_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace hmi

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::hmi::CarOriInterface_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::hmi::CarOriInterface_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::hmi::CarOriInterface_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::hmi::CarOriInterface_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::hmi::CarOriInterface_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::hmi::CarOriInterface_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::hmi::CarOriInterface_<ContainerAllocator> >
{
  static const char* value()
  {
    return "4bf06e5d0a03ba5caee4a614abe96f39";
  }

  static const char* value(const ::hmi::CarOriInterface_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x4bf06e5d0a03ba5cULL;
  static const uint64_t static_value2 = 0xaee4a614abe96f39ULL;
};

template<class ContainerAllocator>
struct DataType< ::hmi::CarOriInterface_<ContainerAllocator> >
{
  static const char* value()
  {
    return "hmi/CarOriInterface";
  }

  static const char* value(const ::hmi::CarOriInterface_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::hmi::CarOriInterface_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# warn cyun 8.24 协议和msg的名称最好对应，不然程序写起来比较麻烦\n"
"# 另外，最好是根据协议来写msg，不然直接写msg，有些数据类型是有问题的\n"
"\n"
"float64  timestamp  #时间戳\n"
"uint8  id   # 车辆ID\n"
"uint8 auto_enable #无人驾驶使能 0-不使能   1-使能\n"
"float32  carspeed    # 车辆速度，单位为m/s\n"
"float32  steerangle    # 车辆转角，左转为正，右转为负\n"
"float32 current_angle # 转角？车轮缺\n"
"int8  gearpos    # 车辆档位信号（01：驻车，02：空挡（N），03：前进（D），04：后退（R），05：无效）\n"
"float32  brake_pressure_request    # 制动行程请求（0-125）\n"
"uint8  brake_enable    # 制动使能（0：不使能  1：制动使能）\n"
"uint8  current_braking_percentage  #制动踏板开度： 取值0～125\n"
"uint8  soc    # 电池当前SOC（0-100）\n"
"uint8  batteryvol    # 电池电压（0-55V）\n"
"uint16  batterydischargecur    # 电池放电电流（0-100A）\n"
"uint8  car_run_mode   #车辆运行模式： 0： ACU控制  1：自动驾驶  2： 急停模式\n"
"int16  throttle_percentage  #油门踏板开度： 取值0～100\n"
"uint8  left_light    #左转向灯状态：0：关闭，1：打开\n"
"uint8  right_light    #右转向灯状态：0：关闭，1：打开\n"
"uint8  reversing_light   #倒车灯状态：0：关闭，1：打开\n"
"uint8  speaker     #喇叭状态：0：关闭，1：打开\n"
"uint8  start_button     #启动按钮状态：0：按键无效，1：按键有效\n"
"uint8  stop_button     #急停按钮状态：0：按键无效，1：按键有效\n"
"uint8  state          # 设备状态，0：状态正常，1：电池箱报警；2：电机控制器报警\n"
"uint8  error          # 错误码；电池箱报警：1：单体过压或欠压，2：放电电流异常，3：电压报警，4：电池温度报警，5：电池SOC过低。电机控制器报警：1：转向电机控制器故障，2：驱动电机控制器故障\n"
"float32  cotton_picker_fan_Enabler_act    #  使能采头与风机，1-使能；0-保持不变；\n"
"float32  cotton_bin_upper_act    # 升棉箱实际状态，1-提升；0-保持不变；\n"
"uint8  cotton_bin_lower_act   # 降棉箱实际状态，1-降低；0-保持不变；\n"
"uint8  cotton_bin_tilting_act   #  棉箱倾斜实际状态，1-倾斜；0-保持不变；\n"
"uint8  cotton_bin_restore_act # 棉箱回正实际状态，1-回正；0-保持不变；\n"
"uint8  cotton_unload_act  # 卸棉花实际状态（传送带），1-卸载；0-保持不变；\n"
"float32  cotton_picker_head_height  # 棉花采头高度，单位：m；\n"
"uint8  Target_primary_gear_act   # 01：低速，02：中速；03：高速；\n"
"uint8  Target_EngineSpeedLevel_act   # 01：低速；02：中速；03：高速；\n"
"int16  Target_speedlever_percentage_act   #车速手柄开度（-100%-100%）   取值【-100, 100】，负数为后退，正数为前进。\n"
"float32  process_time    # 进程处理时间\n"
"\n"
"\n"
"float32 raw_controlled\n"
"\n"
"\n"
"int8 wait_wirectrl# 0-等待 1-等待结束 发送给hmi界面\n"
;
  }

  static const char* value(const ::hmi::CarOriInterface_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::hmi::CarOriInterface_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.timestamp);
      stream.next(m.id);
      stream.next(m.auto_enable);
      stream.next(m.carspeed);
      stream.next(m.steerangle);
      stream.next(m.current_angle);
      stream.next(m.gearpos);
      stream.next(m.brake_pressure_request);
      stream.next(m.brake_enable);
      stream.next(m.current_braking_percentage);
      stream.next(m.soc);
      stream.next(m.batteryvol);
      stream.next(m.batterydischargecur);
      stream.next(m.car_run_mode);
      stream.next(m.throttle_percentage);
      stream.next(m.left_light);
      stream.next(m.right_light);
      stream.next(m.reversing_light);
      stream.next(m.speaker);
      stream.next(m.start_button);
      stream.next(m.stop_button);
      stream.next(m.state);
      stream.next(m.error);
      stream.next(m.cotton_picker_fan_Enabler_act);
      stream.next(m.cotton_bin_upper_act);
      stream.next(m.cotton_bin_lower_act);
      stream.next(m.cotton_bin_tilting_act);
      stream.next(m.cotton_bin_restore_act);
      stream.next(m.cotton_unload_act);
      stream.next(m.cotton_picker_head_height);
      stream.next(m.Target_primary_gear_act);
      stream.next(m.Target_EngineSpeedLevel_act);
      stream.next(m.Target_speedlever_percentage_act);
      stream.next(m.process_time);
      stream.next(m.raw_controlled);
      stream.next(m.wait_wirectrl);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct CarOriInterface_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::hmi::CarOriInterface_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::hmi::CarOriInterface_<ContainerAllocator>& v)
  {
    s << indent << "timestamp: ";
    Printer<double>::stream(s, indent + "  ", v.timestamp);
    s << indent << "id: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.id);
    s << indent << "auto_enable: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.auto_enable);
    s << indent << "carspeed: ";
    Printer<float>::stream(s, indent + "  ", v.carspeed);
    s << indent << "steerangle: ";
    Printer<float>::stream(s, indent + "  ", v.steerangle);
    s << indent << "current_angle: ";
    Printer<float>::stream(s, indent + "  ", v.current_angle);
    s << indent << "gearpos: ";
    Printer<int8_t>::stream(s, indent + "  ", v.gearpos);
    s << indent << "brake_pressure_request: ";
    Printer<float>::stream(s, indent + "  ", v.brake_pressure_request);
    s << indent << "brake_enable: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.brake_enable);
    s << indent << "current_braking_percentage: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.current_braking_percentage);
    s << indent << "soc: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.soc);
    s << indent << "batteryvol: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.batteryvol);
    s << indent << "batterydischargecur: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.batterydischargecur);
    s << indent << "car_run_mode: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.car_run_mode);
    s << indent << "throttle_percentage: ";
    Printer<int16_t>::stream(s, indent + "  ", v.throttle_percentage);
    s << indent << "left_light: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.left_light);
    s << indent << "right_light: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.right_light);
    s << indent << "reversing_light: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.reversing_light);
    s << indent << "speaker: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.speaker);
    s << indent << "start_button: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.start_button);
    s << indent << "stop_button: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.stop_button);
    s << indent << "state: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.state);
    s << indent << "error: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.error);
    s << indent << "cotton_picker_fan_Enabler_act: ";
    Printer<float>::stream(s, indent + "  ", v.cotton_picker_fan_Enabler_act);
    s << indent << "cotton_bin_upper_act: ";
    Printer<float>::stream(s, indent + "  ", v.cotton_bin_upper_act);
    s << indent << "cotton_bin_lower_act: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.cotton_bin_lower_act);
    s << indent << "cotton_bin_tilting_act: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.cotton_bin_tilting_act);
    s << indent << "cotton_bin_restore_act: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.cotton_bin_restore_act);
    s << indent << "cotton_unload_act: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.cotton_unload_act);
    s << indent << "cotton_picker_head_height: ";
    Printer<float>::stream(s, indent + "  ", v.cotton_picker_head_height);
    s << indent << "Target_primary_gear_act: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Target_primary_gear_act);
    s << indent << "Target_EngineSpeedLevel_act: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Target_EngineSpeedLevel_act);
    s << indent << "Target_speedlever_percentage_act: ";
    Printer<int16_t>::stream(s, indent + "  ", v.Target_speedlever_percentage_act);
    s << indent << "process_time: ";
    Printer<float>::stream(s, indent + "  ", v.process_time);
    s << indent << "raw_controlled: ";
    Printer<float>::stream(s, indent + "  ", v.raw_controlled);
    s << indent << "wait_wirectrl: ";
    Printer<int8_t>::stream(s, indent + "  ", v.wait_wirectrl);
  }
};

} // namespace message_operations
} // namespace ros

#endif // HMI_MESSAGE_CARORIINTERFACE_H
